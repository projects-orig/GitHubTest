{
  "name": "varint",
  "version": "5.0.0",
  "description": "protobuf-style varint bytes - use msb to create integer values of varying sizes",
  "main": "index.js",
  "scripts": {
    "test": "node test.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/chrisdickinson/varint.git"
  },
  "keywords": [
    "varint",
    "protobuf",
    "encode",
    "decode"
  ],
  "author": {
    "name": "Chris Dickinson",
    "email": "chris@neversaw.us"
  },
  "license": "MIT",
  "devDependencies": {
    "tape": "~2.12.3"
  },
  "readme": "# varint\n\nencode whole numbers to an array of [protobuf-style varint bytes](https://developers.google.com/protocol-buffers/docs/encoding#varints) and also decode them.\n\n```javascript\nvar varint = require('varint')\n\nvar bytes = varint.encode(300) // === [0xAC, 0x02]\nvarint.decode(bytes) // 300\nvarint.decode.bytes // 2 (the last decode() call required 2 bytes)\n```\n\n## api\n\n### varint = require('varint')\n\n### varint.encode(num[, buffer=[], offset=0]) -> buffer\n\nEncodes `num` into `buffer` starting at `offset`. returns `buffer`, with the encoded varint written into it. If `buffer` is not provided, it will default to a new array.\n\n`varint.encode.bytes` will now be set to the number of bytes\nmodified.\n\n### varint.decode(data[, offset=0]) -> number\n\ndecodes `data`, which can be either a buffer or array of integers, from position `offset` or default 0 and returns the decoded original integer.\n\nThrows a `RangeError` when `data` does not represent a valid encoding.\n\n### varint.decode.bytes\n\nif you also require the length (number of bytes) that were required to decode the integer you can access it via `varint.decode.bytes`. this is an integer property that will tell you the number of bytes that the last .decode() call had to use to decode.\n\n### varint.encode.bytes\n\nsimilar to `decode.bytes` when encoding a number it can be useful to know how many bytes where written (especially if you pass an output array). you can access this via `varint.encode.bytes` which holds the number of bytes written in the last encode.\n\n\n### varint.encodingLength(num)\n\nreturns the number of bytes this number will be encoded as, up to a maximum of 8.\n\n## usage notes\n\nIf varint is passed a buffer that does not contain a valid end\nbyte, then `decode` will throw `RangeError`, and `decode.bytes` \nwill be set to 0. If you are reading from a streaming source,\nit's okay to pass an incomplete buffer into `decode`, detect this\ncase, and then concatenate the next buffer.\n\n# License\n\nMIT\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/chrisdickinson/varint/issues"
  },
  "_id": "varint@5.0.0",
  "dist": {
    "shasum": "e6a6bd61f7fb32510ad363dc07383d02f472e8fb"
  },
  "_from": "varint@^5.0.0",
  "_resolved": "https://registry.npmjs.org/varint/-/varint-5.0.0.tgz"
}
